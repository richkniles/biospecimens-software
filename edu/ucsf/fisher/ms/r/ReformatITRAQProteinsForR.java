package edu.ucsf.fisher.ms.r;

import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.PrintStream;
import java.util.Arrays;
import java.util.HashMap;
import java.util.TreeSet;

import edu.ucsf.library.util.FileUtil;

/*
**
**  This program reads as input, Protein Summary files generated by AB Sciex ProteinPilot Software
**
**  To use this program export results from ProteinPilot as ProteinSummaries.  Edit the main to open
**  the resulting folder containing the files.  The output file will be ready to import into R.
**
**
*/

public class ReformatITRAQProteinsForR 
{
	static class Label
	{
		String proc;
		String trt;
		public Label(String proc, String trt) 
		{
			super();
			this.proc = proc;
			this.trt = trt;
		}
		public String toString()
		{
			return proc + " " + trt;
		}
	}
	static void printALine(PrintStream out, String donor, String accessions, String name, String spl[], Label ratioLabels[], int ratioColumns[])
	{
		
		String accs[] = accessions.split("; ");
		Arrays.sort(accs);
		accessions = accs[0];
		for (int i = 1; i < accs.length; i++)
			accessions += "; " + accs[i];
		
		//0 1       2       3       4           5           6           7       8       9                       10      
		//N	Unused	Total	%Cov	%Cov(50)	%Cov(95)	Accession	Name	Species	Peptides(95%)			113:118	PVal 113:118	EF 113:118	LowerCI 113:118	UpperCI 113:118	114:118	PVal 114:118	EF 114:118	LowerCI 114:118	UpperCI 114:118	115:118	PVal 115:118	EF 115:118	LowerCI 115:118	UpperCI 115:118	116:118	PVal 116:118	EF 116:118	LowerCI 116:118	UpperCI 116:118	117:118	PVal 117:118	EF 117:118	LowerCI 117:118	UpperCI 117:118	119:118	PVal 119:118	EF 119:118	LowerCI 119:118	UpperCI 119:118	121:118	PVal 121:118	EF 121:118	LowerCI 121:118	UpperCI 121:118	Biological Processes	Molecular Function	PANTHER ID
		
		for (int ir = 0; ir < 7; ir++)
		{
			String trt = ratioLabels[ir].trt;
			if (trt.equals("Pool") || trt.equals("Control") || trt.equals("pool"))
				continue;
			if (spl.length > ratioColumns[ir]) //+ 1 && !spl[ratioColumns[ir]+1].isEmpty())
			{
				out.println(donor + "\t" + accessions + "\t" + name + "\t" + spl[1] + "\t" + ratioLabels[ir].proc + "\t" + trt + "\t" + spl[ratioColumns[ir]] + "\t" + spl[ratioColumns[ir]+1]);
				
				// keep track of donors for this peptide		{
				TreeSet<String> donorsThisProteinTrt = donorCountsForProteinTrt.get(accessions + ":" + trt);
				if (donorsThisProteinTrt == null)
					donorCountsForProteinTrt.put(accessions + ":" + trt, donorsThisProteinTrt = new TreeSet<String>());
				donorsThisProteinTrt.add(donor);
			}
		}
		
	}
	
	//keep track of number of donors for each protein
	static HashMap<String, TreeSet<String>> donorCountsForProteinTrt = new HashMap<String,TreeSet<String>>();
	static HashMap<String, TreeSet<String>> pepAccs = new HashMap<String,TreeSet<String>>();
	
	public static void main(String args[]) throws Exception
	{
		double unusedThreshold = 1.3;
		int nDonors = 5;
		
		String iTRAQReps[] = {"113", "114","115","116","117","118","119","121"};
		TreeSet<String> iTRAQReporters = new TreeSet<String>();
		for(String r : iTRAQReps)
			iTRAQReporters.add(r);
		
		//String folder = "/Volumes/work/lab/Biospecimens-Contract/Expts/iTRAQ/iTRAQ Data Superabuse_2 9 donors/30min CPTAC Denom/";
		//String folder = "/Volumes/work/lab/Biospecimens-Contract/Expts/iTRAQ/iTRAQ Data Superabuse_2 9 donors/All Donors All Fractions/";
		//String folder = "/Volumes/work/lab/Biospecimens-Contract/Expts/iTRAQ/Plasma iTRAQ Data_50 donors/group files/Good ones xml done/Protein and Peptide Summaries/";
		String folder = "/Volumes/lab/Biospecimens-Contract/Expts/iTRAQ/Plasma iTRAQ data_50 donors/group files/Good ones xml done/Protein and Peptide Summaries/";
		
		String outFile = folder + "S" +
				"Study 1 proteins for R" + unusedThreshold + "WithExtremes.txt";
		PrintStream out = new PrintStream(new BufferedOutputStream(new PrintStream(new FileOutputStream(outFile))));

		out.println("Donor" + "\t" + "Accession" +  "\t" + "Name" + "\t" + "Conf" + "\t" + "Proc" + "\t" + "Trt" + "\t" + "Val" + "\t" + "Err");
		
		// read in itraq labels
		
		HashMap<String, Label> labels = new HashMap<String,Label>();
		
		BufferedReader in = new BufferedReader(new FileReader(folder + "iTRAQ key for Rich.txt"));
		String line;
		while((line = in.readLine()) != null)
		{
			if (!line.startsWith("D0"))
				continue;
			String spl[] = line.split("\t");
			String donor = spl[0];
			String reporter = spl[1];
			String proc = spl[3];
			String trt = spl[4];
			labels.put(donor+":" + reporter, new Label(proc, trt));
		}
		in.close();
		TreeSet<String> allTreatments = new TreeSet<String>();
		for (String key : labels.keySet())
			allTreatments.add(labels.get(key).trt);
		TreeSet<String> allProcs = new TreeSet<String>();
		for (String key : labels.keySet())
			allProcs.add(labels.get(key).proc);
		
		//Get the file list
		
		File fileList[] = FileUtil.getFileList(new File(folder), "ProteinSummary.txt", false);
		for (File f : fileList)
		{
			if (f.getName().startsWith("."))
				continue;
			
			String donor = f.getName().split("[_ ]")[0];
			donor = "D" + /*"D0" +*/ donor.substring(1);
			
			in = new BufferedReader(new FileReader(f));
			line = in.readLine();
			String spl[] = line.split("\t");
			int ratioColumns[] = new int[7];
			Label ratioLabels[] = new Label[7];
			int iRatioColumn = 0;
			
			for (int column = 0; column < spl.length; column++)
			{
				String h = spl[column];
				if (h.contains(":") && h.startsWith("1"))
				{
					String hspl[] = h.split(":");
					if (hspl.length==2 && iTRAQReporters.contains(hspl[0]) && iTRAQReporters.contains(hspl[1]))
					{
						String num = hspl[0];
						String denom = hspl[1];
						
						// see if we know this one
						Label lnum = labels.get(donor + ":" + num);
						if (lnum == null)
							throw new Exception("don't recognize " + donor + ":" + num);
						Label ldenom = labels.get(donor + ":" + denom);
						if (ldenom == null)
							throw new Exception("don't recognize " + donor + ":" + denom);
						
						if ((!ldenom.proc.equals("CPTAC") || (!ldenom.trt.equals("pool") && !ldenom.trt.equals("30 min"))) && !ldenom.trt.equals("Control"))
							throw new Exception ("wrong denominator: " + ldenom.proc + " " + ldenom.trt);
						
						ratioColumns[iRatioColumn] = column;
						ratioLabels[iRatioColumn] = lnum;
						iRatioColumn++;
					}
				}
			}
			//String labelList = "";
			//for(Label l: ratioLabels)
			//	labelList += l.proc + " " + l.trt + ", ";
			//System.out.println(f.getName() + " " + labelList);
			
			// now read the file and output all the needed stuff
			//0 1       2       3       4           5           6           7       8       9                       10      
			//N	Unused	Total	%Cov	%Cov(50)	%Cov(95)	Accession	Name	Species	Peptides(95%)			113:118	PVal 113:118	EF 113:118	LowerCI 113:118	UpperCI 113:118	114:118	PVal 114:118	EF 114:118	LowerCI 114:118	UpperCI 114:118	115:118	PVal 115:118	EF 115:118	LowerCI 115:118	UpperCI 115:118	116:118	PVal 116:118	EF 116:118	LowerCI 116:118	UpperCI 116:118	117:118	PVal 117:118	EF 117:118	LowerCI 117:118	UpperCI 117:118	119:118	PVal 119:118	EF 119:118	LowerCI 119:118	UpperCI 119:118	121:118	PVal 121:118	EF 121:118	LowerCI 121:118	UpperCI 121:118	Biological Processes	Molecular Function	PANTHER ID
			
			int countOutputLines = 0;
			String prevN = "";
			String accessions = "";
			String name = "";
			String firstSpl[] = null;
			while ((line = in.readLine()) != null)
			{
				spl = line.split("\t");
				
				double unused = Double.parseDouble(spl[1]);
				if (unused < unusedThreshold)
					continue;

				
				String N = spl[0];
				String accession = spl[6];
				String aParts[] = accession.split("\\|");
				accession = aParts[2];
				if (aParts[0].startsWith("RRRRR"))
					accession = "RRRRR_" + accession;

				// skip reverse hits
				if (accession.startsWith("RRRRR_"))
					continue;
				
				
				if (!prevN.equals(N))
				{
					if (firstSpl != null)
					{
						printALine(out, donor, accessions, name, firstSpl, ratioLabels, ratioColumns);
						countOutputLines += 7;
					}
					prevN = N;
					firstSpl = spl;
					accessions = accession;
					name = spl[7];
				}
				else 
				{
					accessions += "; " + accession;
				}
			}
			if (firstSpl != null)
			{
				printALine(out, donor, accessions, name, firstSpl, ratioLabels, ratioColumns);
				countOutputLines += 7;
			}
			System.out.println(f.getName() + "\t" + countOutputLines);
		}
		out.close();
		
		// now read back, keeping only the ones with data for >= 5 donors
		in = new BufferedReader(new FileReader(outFile));
		out = new PrintStream(new BufferedOutputStream(new PrintStream(new FileOutputStream(outFile.replaceAll("\\.txt", " " + nDonors + " Donors.txt")))));
		out.println(in.readLine()); // copy the header
		while((line = in.readLine()) != null)
		{
			String spl[] = line.split("\t");
			String accessions = spl[1];
			boolean useThisProtein = true;
			for (String trt : allTreatments)
			{
				if (trt.toLowerCase().equals("pool") || trt.toLowerCase().equals("control"))
					continue;
				TreeSet<String> donorsThisProteinTrt = donorCountsForProteinTrt.get(accessions + ":" + trt);
				if (donorsThisProteinTrt == null || donorsThisProteinTrt.size() < nDonors)
					useThisProtein = false;
			}
			if (useThisProtein)
				out.println(line);
		}
		out.close(); 
	}
}
